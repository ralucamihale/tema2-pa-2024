    PROBLEMA 1 - NUMARARE
    Am declarat 3 grafuri, reprezentate sub forma de liste de adiacenta (unordered_map): g1 este primul graf citit, g2 este al doilea graf citit, iar g este graful care contine muchiile comune dintre cele 2 grafuri.
    Am citit datele de intrare, apoi am parcurs cele 2 grafuri pentru a extrage din acestea muchiile comune in graful g.
    Am folosit un algoritm de programare dinamica, care calculeaza numarul de drumuri pentru fiecare nod, de la N-1 la 1, adunand numarul de drumuri ale nodurilor vecine. Astfel, fiecare element i din drumuri contine numarul de drumuri de la i la N.
    Numarul de lanturi elementare comune cerut este stocat in elementul drumuri[1], deci il afisam.

    PROBLEMA 2 - TRENURI
    Am implementat functia topoSort, cu urmatorii paramentri: x - nodul curent, drumuri - lista de adiacenta a grafului retelei de trenuri, visited - map care retine daca un nod a fost vizitat si stack - stiva care retine ordinea topologica a nodurilor. Functia marcheaza nodul curent ca fiind vizitat, apoi este apelata recursiv pentru toate nodurile adiacente celui curent, iar in final adauga nodul curent in stiva.
    In functia longestPath, se face intai sortarea topologica a nodurilor din graful de drumuri. Apoi, se declara un map care retine lungimea maxima a unui lant (arcele dintre ele) de la nodul de start la nodul curent i si se initializeaza cu -1 pentru a indica ca sunt inaccesibile, exceptie facand dist[start], care este initializat cu 0. Se parcurge stiva de noduri sortate topologic si se actualizeaza distantele pentru toate nodurile adiacente lui x in cazul in care s-a gasit o distanta mai lunga. Se returneaza ultimul element al map-ului de distante (cel mai lung drum de la start la end), la care se aduna 1, pentru ca functia numara arcele, la care trebuie adaugat nodul final.
    In main, am citit datele de intrare, am apelat functia longestPath pe graful drumuri, nodul de inceput si nodul final si am afisat rezultatul.

    PROBLEMA 3 - DRUMURI
    Pentru a rezolva problema, am pornit de la rezolvarea laboratorului 8.
    Am declarat o structura DijkstraResult care contine un vector d care contine distantele de la nodul de start la fiecare nod in parte, si un vector p, care contine parintii fiecarui nod in drumul minim. Am declarat si 2 grafuri, reprezentate sub forma de vector de perechi: g, care reprezinta graful original, si reverse_g, graful inversat.
    Functia dijkstra reprezinta o implementare a algoritmului Dijkstra. Se initializeaza vectorul de drumuri cu un numar foarte mare, iar cel de parinti cu 0. In coada de prioritati pq (implementata ca un set de perechi de distanta si nod) se introduce nodul de start. Din coada se extrage pe rand nodul cu distanta minima si se actualizeaza distantele pentru vecinii sai. Daca distanta gasita este mai mica decat cea initiala, atunci vecinul este actualizat in pq. Nodurile care au ramas cu distanta 1000000000009 sunt considerate inaccesibile si se marcheaza cu -1. Se returneaza rezultatul format din vectorul d si vectorul p.
    Functia compute_min_cost calculeaza costul minim. Se apeleaza functia dijkstra de 3 ori: distToZ reprezinta distanta de la toate nodurile la z in graful inversat, iar distFromX si distFromY reprezinta distanta de la x, respectiv y, la toate nodurile in graful original. Se itereaza prin toate nodurile, se verifica intai daca acestea sunt accesibile, se calculeaza prin adunarea distFromX, distFromY si distToZ costul curent al drumului si se actualizeaza costul minim daca e cazul. Se returneaza costul minim.
    In main, se citesc datele de intrare, se construiesc grafurile g si reverse_g, se apeleaza functia compute_min_cost si se afiseaza rezultatul.